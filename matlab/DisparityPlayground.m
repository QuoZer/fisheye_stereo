
SHOW = false;
distances = [4 5 6 7.5 10 12.5 15]; %  //  13
regErrors = [];
fyErrors = [];

for dst = distances

    %%%     FISHEYE        %%%
    fy_e = computePlaneError(newFisheyeStereoParams, dst, "fy", SHOW);
    fyErrors = [fyErrors fy_e];
    %%%     REGULAR        %%%
    reg_e = computePlaneError(newRegularStereoParams, dst, "reg", SHOW);
    regErrors = [regErrors reg_e];
    disp("Distance  ready")
end

createfigure(distances, [regErrors; fyErrors])



function [MSE]  = computePlaneError(stereoParams, distance, type, show)
    base_path = "D:\Work\Coding\Repos\RTC_Practice\fisheye_stereo\data\stereo_img\compar\plane" + string(distance) + "m\";

    targetDistance = distance;
    target_roi = [-0.4 0.6 -0.6 0.46 targetDistance/10-0.05 targetDistance/10+0.05];

    targetParamsVector = [0, 0, 1, -targetDistance/10];   % normal + distance
    ref_model = planeModel(targetParamsVector);

    imgRight = base_path + type + "_r_shot.jpg";
    imgLeft = base_path + type + "_l_shot.jpg";

    lImage = imread(imgLeft);
    rImage = imread(imgRight);

    [frameLeftRect, frameRightRect] = rectifyStereoImages(lImage, rImage, stereoParams);

    %figure;
    %imshow(stereoAnaglyph(frameLeftRect, frameRightRect));
    %title('Rectified Video Frames');

    frameLeftGray  = rgb2gray(frameLeftRect);
    frameRightGray = rgb2gray(frameRightRect);

    disparityMapReg = disparitySGM(frameLeftGray, frameRightGray);
    % figure;
    % imshow(disparityMapReg, [0, 64]);
    % title('Disparity Map');
    % colormap jet
    % colorbar

    points3Dreg = reconstructScene(disparityMapReg, stereoParams);
    points3Dreg = points3Dreg ./ 1000;
    ptCloud = pointCloud(points3Dreg, 'Color', frameLeftRect);
    indicies = findPointsInROI(ptCloud, target_roi);
    ptCloud = select(ptCloud, indicies);
% 
     MSE = findMSE(ptCloud,  ref_model);

    if (show)    
        disp(type+"ERROR: ")
        disp(MSE)
        % Visualize the point cloud
        figure('Name',type+' depth')
        pcshow(ptCloud);
        hold on
        plot(ref_model, 'color', 'white')
        hold off
    end
end

function [MSE] = findMSE(pt_cloud, plane_model)
    errorSum = 0.0;
%    figure;
%     Animated_Plot = animatedline;
    for elm = 1:pt_cloud.Count
        pnt = pt_cloud.Location(elm,:);
        pnt_error = findSquareError(pnt, plane_model);
        errorSum = errorSum + pnt_error;
        
        %hold on
        %addpoints(Animated_Plot, elm,  double(errorSum) );
        
%         if (mod(elm, 100) == 0)
%             double(pnt_error)
%             drawnow
%         end
        
    end
    
    MSE = sqrt(errorSum/pt_cloud.Count);
end

function [error] = findSquareError(point, plane)
    planePoint = [0, 0, -plane.Parameters(4)];  % plane center
    PQ = point - planePoint;
    error = (dot(PQ, plane.Normal)*10 )^2;     % squared difference
end

function createfigure(X1, YMatrix1)
%CREATEFIGURE(X1, YMatrix1)
%  X1:  vector of x data
%  YMATRIX1:  matrix of y data

%  Auto-generated by MATLAB on 16-Jan-2022 02:26:31

% Create figure
figure1 = figure;

% Create axes
axes1 = axes('Parent',figure1);
hold(axes1,'on');

% Create multiple lines using matrix input to plot
plot1 = plot(X1,YMatrix1,'Marker','square');
set(plot1(1),'DisplayName','"Традиционная" стереопара');
set(plot1(2),'DisplayName','Предлагаемая стереосистема');

% Create ylabel
ylabel('Ошибка оценки  поверхности, м');

% Create xlabel
xlabel('Расстояние до поверхности, м');

% Uncomment the following line to preserve the X-limits of the axes
 xlim(axes1,[-0.000209902368405811 16.0517554642163]);
% Uncomment the following line to preserve the Y-limits of the axes
 ylim(axes1,[-3.8322756199846e-05 0.35351683918712]);
box(axes1,'on');
% Set the remaining axes properties
set(axes1,'XGrid','on','YGrid','on');
% Create legend
legend1 = legend(axes1,'show');
set(legend1,...
    'Position',[0.172415836709068 0.839227796053986 0.262158950099176 0.0602310215285902]);
end



% maxDistance = 0.02;
% referenceVector = [0, 0, 1];
% maxAngularDistance = 0;
% [model1,inlierIndices,outlierIndices, meanError] = pcfitplane(ptCloud,maxDistance,referenceVector,maxAngularDistance);
% plane1 = select(ptCloud,inlierIndices);
% remainPtCloud = select(ptCloud,outlierIndices);
% meanError   % print mean square error in distance